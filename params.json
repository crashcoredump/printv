{"name":"printv","tagline":"A batteries-included tracing and debug-logging macro","body":"printv\r\n======\r\n\r\n> PRINTV is a 'batteries-included' tracing and debug-logging macro based\r\n> on __\"The Handy PRINTV\"__ by *Dan Corkill, Copyright (c) 2006-2010*,\r\n> and open-source licensed under the terms of Apache License version 2.\r\n\r\n\r\n### Motivation\r\n\r\nThere are a variety of sophisticated debugging facilities available to\r\nthe common-lisp programmer, and as well a number of very capable\r\nlogging utilities that range from very simple tools to fairly complex\r\napplication-grade suites.  In spite of this, one utility which I\r\nalmost always wind up turning to is the *\"Handy PRINTV Macro\"* that is\r\ndistributed as part of the GBBopen suite.  It is an effective\r\nsubistitute for tracing evaluation with ad-hoc printing forms that\r\ndoesn't require one to compose legions of cumbersome logging, PRINT or\r\nFORMAT calls that explicitly enumerate each value one wishes to\r\nincorporate into the trace.  It also provides a standardized format\r\nfor your debug-logging output that is both consistent and easy to\r\ninterpret via quick \"eyeball\" inspection. Debug-logging a trace of the\r\nevaluation of program forms may be easily incorporated into existing\r\ncode by simply enclosing the form or forms within a PRINTV macro-call\r\n(implicit progn).  __PRINTV always respects multiple-values__.\r\n\r\nAs I have wound up copying this utility from project to project,\r\nincorporating various extensions and tweaks along the way, it occurred\r\nto me that it was probably time to spin off my \"extended\" PRINTV into\r\na standalone library.  Also included is the Clozure Associates' *PPMX*\r\nmacro-expansion macro which is very useful in its own right, and has\r\nproven invaluable during development and debugging of PRINTV.\r\n\r\nThe extended features implemented (in addition to making PRINTV available\r\nindependently of the massive GBBopen project) include:\r\n\r\n* Thread Safety\r\n* Tracing lexical variable assignments in LET and LET* forms\r\n* Tracing conditional evaluations inside COND forms\r\n* Support a variety of output destinations, including to files and to arbitrary\r\n  user-defined streams.\r\n* Character-macro to support DWIM *'PRINTV the following form'* reader extension\r\n  instead of unsightly, cumbersome, and error-prone nesting of (PRINTV\r\n  ...) s-expression structure that becomes increasingly problematic\r\n  to understand and even more-so to (eventually) remove\r\n* Support for fully disabling printv with global or dynamic extent in order to \r\n  allow printv instrumented code to operate at full performance that should be\r\n  nearly identical to that of equivalent to code without such\r\n  instrumentation.\r\n* Support enablement and disablement of PRINTV output to user-selected stream\r\n  (initially \\*TRACE-OUTPUT\\*) effective for global or dynamic extent.\r\n* Support for additional typographic functionality that can generate\r\n  output that is both attractive and utilitarian for structuring\r\n  trace output in a manner that is easy to discern by eye and to navigate when\r\n  seeking a particular segment of output.   Included are: \r\n   * Major Separator (thick horizontal rule)\r\n   * Minor Separator (thin horizontal rule)\r\n   * Human Readable Timestamp\r\n   * Banner Text     (FIGLET generated)  \r\n* Macro bindings on keywords (:PRINTV, :PPMX) in addition to standard\r\n  symbols (PRINTV:PRINTV, PRINTV:PPMX) for ease of use globally\r\n* Inclusion of PPMX macro-expander distributed by Clozure Associates with\r\n  their excellent Common-Lisp implementation: *Clozure Common Lisp*\r\n\r\n### Usage\r\n\r\nTo start, here's a quick example that shows a few features in action:\r\n\r\n    CL-USER> (:printv                \r\n               :|.. printv-output ..|\r\n               \"\"\r\n               :hr\r\n               :ts\r\n               :hr\r\n               \"\"\r\n               \"This is an example composition testing various PRINTV functionalities.\"\r\n               \"Self-evaluation of strings may be used within a PRINTV form to augment\"\r\n               \"the log output with annotations or other commentary.\"\r\n               \"\" \r\n               :hr\r\n               \"\" \r\n               (+ 2 3)              \r\n               *print-case*\r\n               *package*\r\n               'symbol\r\n               (let* ((x 0) (y (1+ x)) (z (1+ y)))\r\n                 (values x y z)))\r\n\r\nprints the following:\r\n\r\n    #||\r\n                      _       _                          _               _         \r\n           _ __  _ __(_)_ __ | |___   __      ___  _   _| |_ _ __  _   _| |_       \r\n          | '_ \\| '__| | '_ \\| __\\ \\ / /____ / _ \\| | | | __| '_ \\| | | | __|      \r\n     _ _  | |_) | |  | | | | | |_ \\ V /_____| (_) | |_| | |_| |_) | |_| | |_   _ _ \r\n    (_|_) | .__/|_|  |_|_| |_|\\__| \\_/       \\___/ \\__,_|\\__| .__/ \\__,_|\\__| (_|_)\r\n          |_|                                               |_|                    \r\n    ||#\r\n    ;;;\r\n    ;;; ------------------------------------------------------------------------ ;;;\r\n    ;;; .............. Wednesday, April 17, 2013 06:39:03 PM EDT ............... ;;;\r\n    ;;; ------------------------------------------------------------------------ ;;;\r\n    ;;; \r\n    ;;; This is an example composition testing various PRINTV functionalities.\r\n    ;;; Self-evaluation of strings may be used within a printv form to augment\r\n    ;;; the log output with annotations or other commentary.\r\n    ;;; \r\n    ;;; ------------------------------------------------------------------------ ;;;\r\n    ;;;\r\n    ;;;   (+ 2 3) => 5\r\n    ;;;   *PRINT-CASE* => :UPCASE\r\n    ;;;   *PACKAGE* => #<PACKAGE \"COMMON-LISP-USER\">\r\n    ;;;   'SYMBOL => SYMBOL\r\n    ;;;   (LET* ((X 0) (Y (1+ X)) (Z (1+ Y)))\r\n            (VALUES X Y Z)) =>\r\n               [ [X=0]  [Y=1]  [Z=2] ]\r\n    ;;;   => 0, 1, 2\r\n\r\nand returns multiple-values:\r\n\r\n    0\r\n    1\r\n    2\r\n\r\n#### Basic Form Evaluation and Tracing \r\n\r\nThe fundamental purpose of PRINTV is to log a trace of the forms\r\nwithin its lexical scope and to log the result of their evaluation to\r\na specified output destination.  This allows the user to closely monitor\r\nthe execution of program code, to better understand its\r\noperation, and to quickly identify problems that may occur due to\r\nundexpected results.\r\n\r\nHere is a simple example that illustrates this basic functionality.\r\nSay one has written the following code to perform some desired\r\ncalculation:\r\n\r\n    (defvar *y*) \r\n    (defparameter *x* 2)\r\n    (setf *y* (sqrt *x*))\r\n    (setf *y* (/ 1 *y*))\r\n    \r\nEvaluation of this block of code results in the value `0.70710677.`\r\nTo understand more clearly (or simply to track), it's operation, one\r\ncan simply enclose the code within PRINTV. The principlal benefit of\r\ninstrumenting your code with PRINTV derives from the capability to produce\r\na trace, form by form as they are evaluated, and possibly to archive this\r\ndetailed record of its execution to persistent storage media.\r\n\r\n    (:printv\r\n      (defvar *y*) \r\n      (defparameter *x* 2)\r\n      (setf *y* (sqrt *x*))\r\n      (setf *y* (/ 1 *y*)))\r\n      \r\nThis produces the following text to PRINTV's output stream, and still\r\nresults in the same returned value:  `0.70710677.`\r\n\r\n    ;;;   (DEFVAR *Y*) => *Y*\r\n    ;;;   (DEFPARAMETER *X* 2) => *X*\r\n    ;;;   (SETF *Y* (SQRT *X*)) => 1.4142135\r\n    ;;;   (SETF *Y* (/ 1 *Y*)) => 0.70710677\r\n\r\nTo take a step further, one might augment the block of code as\r\nfollows:\r\n\r\n    (:printv\r\n      (defvar *y*) \r\n      (defparameter *x* 2)\r\n      (setf *y* (sqrt *x*))\r\n      *x*\r\n      *y*\r\n      (setf *y* (/ 1 *y*)))\r\n\r\nprints:\r\n\r\n    ;;;   (DEFVAR *Y*) => *Y*\r\n    ;;;   (DEFPARAMETER *X* 2.0) => *X*\r\n    ;;;   (SETF *Y* (SQRT *X*)) => 1.4142135\r\n    ;;;   *X* => 2.0\r\n    ;;;   *Y* => 1.4142135\r\n    ;;;   (SETF *Y* (/ 1 *Y*)) => 0.70710677\r\n\r\nand correctly returns the value of the final form:\r\n\r\n    0.70710677\r\n\r\nThe semantics (apart from tracing the evaluation of enclosed forms)\r\nare exactly as in PROGN -- the idea being that PRINTV may be used\r\nliberally just about anywhere, without changing the meaning or\r\noperation of the forms enclosed.  Notice that bound symbols are also\r\n'forms'.  Inclusion of `*x*` and `*y*` forms within the implicit-progn\r\nof a PRINTV expression (in any but the last position) has no effect on\r\nthe overall semantics of the given of code, but a record of the\r\nsymbol-name and its value at the current point of execution is\r\nincorporated into the text sent to PRINTV's output stream.  This is\r\nthe essence of logging with PRINTV.\r\n\r\nSelf-evaluating forms, such as literal strings, are also useful within\r\nthe context of PRINTV.  Since they evaluate to themselves, there is\r\nlittle point in showing the result of this evaluation. Instead,\r\nself-evaluating forms are handled specially in order to provide\r\nadiitional capabilities that may be useful within PRINTV's logging\r\noutput.  In the case of literal strings, the text of the string is\r\npresented directly within the logging output, providing a quick means\r\nof augmenting your logs with descriptive annotations or other helpful\r\nexposition:\r\n\r\n    (:printv\r\n      \"This was my homework assignment over spring break\"\r\n      \"\"\r\n      (defvar *y*) \r\n      (defparameter *x* 2)\r\n      (setf *y* (sqrt *x*))\r\n      (setf *y* (/ 1 *y*)))\r\n\r\nThis produces a slightly more informative output to the PRINTV\r\nstream. Notice that the empty string `\"\"` was used to insert a 'blank'\r\nline within the logged output:\r\n\r\n    ;;; This was my homework assignment over spring break\r\n    ;;; \r\n    ;;;   (DEFVAR *Y*) => *Y*\r\n    ;;;   (DEFPARAMETER *X* 2) => *X*\r\n    ;;;   (SETF *Y* (SQRT *X*)) => 1.4142135\r\n    ;;;   (SETF *Y* (/ 1 *Y*)) => 0.70710677\r\n    \r\nOne might make use of other simple self-evaluating forms, such as\r\nnumbers and 'ordinary' keywords (more on these later) to further\r\nannotate the output:\r\n\r\n    (:printv :FINAL-ANSWER  \"\" 0.70710677)\r\n\r\nPrints:\r\n\r\n    ;;;   :FINAL-ANSWER\r\n    ;;; \r\n    ;;;   0.70710677\r\n\r\nFinally, you may rely on PRINTV to always respect multiple-values,\r\nwhich are denoted in logging output as a series of comma-separated\r\nforms. Multiple-values are always correctly returned when produced by\r\nevaluation of any form, both within PRINTV's implicit progn and when\r\nproduced as the result of the final form:\r\n\r\n    (:printv\r\n       (values 1 2 3)\r\n       (values 'a 'b 'c))\r\n\r\nLogs the following:           \r\n\r\n    ;;;   (VALUES 1 2 3) => 1, 2, 3\r\n    ;;;   (VALUES 'A 'B 'C) => A, B, C\r\n\r\nAnd returns as multiple-values:\r\n\r\n    A\r\n    B\r\n    C\r\n    \r\n#### LET, LET*, and COND: Binding Forms and Conditional Clauses\r\n\r\nFor certain, more structurally complex forms, simply printing the\r\nvalue to which it evaluates does not necessarily provide much insight\r\nas to how that value may have been arrived at.  Lexical binding forms,\r\nLET and LET*, are such a case.  These forms often perform significant\r\ncalculations as part of their initial binding lists that are\r\nsubsequently referenced by the following series of form(s) within\r\ntheir implicit progn. For example, the following code should return\r\na humanly readable string that denotes the time exactly 24 hours ago:\r\n\r\n    (let* ((a (get-universal-time))\r\n           (b (- a 86400)))\r\n       (format-universal-time nil b))\r\n\r\nMight return `\"Tuesday, April 16, 2013 11:45:50 AM EDT\"`, but the\r\nsignificant calculation that is performed to arrive at this result is\r\nnot apparent from just the result of this evaluation. To get a better\r\nunderstanding what is happening, one needs to see the values that are\r\nlexically bound to the symbols `a` and `b`. PRINTV supports this kind\r\nof introspection by providing special handling of LET and LET* binding\r\nforms:\r\n\r\n    (printv\r\n      (let* ((a (get-universal-time))\r\n             (b (- a 86400)))\r\n         (format-universal-time nil b)))\r\n\r\nLogs the following:\r\n\r\n    ;;;   (LET* ((A (GET-UNIVERSAL-TIME)) (B (- A 86400)))\r\n            (FORMAT-UNIVERSAL-TIME NIL B)) =>\r\n               [ [A=3575203206]  [B=3575116806] ]\r\n    ;;;   => \"Tuesday, April 16, 2013 12:00:06 PM EDT\"\r\n\r\nNotice the values bound to `a` and `b` are logged with a printed\r\nrepresentation denoted by square brackets.\r\n\r\nSimilarly, within COND forms, evaluation of the clause heads is of\r\ninterest not only to track what they evaluate *to*, but also to see\r\n*which* ones are evaluated *at all* (COND clauses provide\r\nshort-circuiting semantics).  PRINTV provides special handling for\r\nthese as well:\r\n\r\n    (printv\r\n      (cond\r\n        ((null     :x) (values \"no\"  1))\r\n        ((stringp  :x) (values \"no\"  2))\r\n        ((symbolp  :x) (values \"no\"  3))\r\n        ((keywordp :x) (values \"yes\" 4))\r\n        (t             (values \"no\"  5))))\r\n\r\nLogs the following:\r\n          \r\n    ;;;   (COND ((NULL :X) (VALUES \"no\" 1)) ((STRINGP :X) (VALUES \"no\" 2))\r\n                ((SYMBOLP :X) (VALUES \"no\" 3)) ((KEYWORDP :X) (VALUES \"yes\" 4))\r\n                (T (VALUES \"no\" 5))) =>\r\n           [(NULL :X) -> NIL]\r\n           [(STRINGP :X) -> NIL]\r\n           [(SYMBOLP :X) -> T]          \r\n    ;;;   => \"no\", 3\r\n\r\nAnd returns multiple-values:\r\n\r\n    \"no\"\r\n    3\r\n\r\nNotice that each cond clause evaluated, depicted by a bracketed\r\n*[clause -> result]* representation, is displayed below the COND form\r\nand before the final result in the printv output text.  By examining\r\nthis output, it is evident that the successful clause head was\r\n`(symbolp :x)` which, of course, is true, but that the more specific\r\nclause head `(keywordp :x)` that, most likely, was the author's\r\nintent, was never evaluated. This is a common error which can be fixed\r\nby reordering the two clauses, but one that can be sometimes be\r\nelusive in actual code.  With PRINTV, it was immediately obvious what\r\nthe problem was and how to resolve it:\r\n\r\n    (printv\r\n      (cond\r\n        ((null     :x) (values \"no\"  1))\r\n        ((stringp  :x) (values \"no\"  2))\r\n        ((keywordp :x) (values \"yes\" 3))        \r\n        ((symbolp  :x) (values \"no\"  4))\r\n        (t             (values \"no\"  5))))\r\n\r\nNow logs:\r\n          \r\n    ;;;   (COND ((NULL :X) (VALUES \"no\" 1)) ((STRINGP :X) (VALUES \"no\" 2))\r\n                ((KEYWORDP :X) (VALUES \"yes\" 3)) ((SYMBOLP :X) (VALUES \"no\" 4))\r\n                (T (VALUES \"no\" 5))) =>\r\n           [(NULL :X) -> NIL]\r\n           [(STRINGP :X) -> NIL]\r\n           [(KEYWORDP :X) -> T]          \r\n    ;;;   => \"yes\", 3\r\n\r\nAnd, as was the programmer's intent, now correctly returns:\r\n\r\n    \"yes\"\r\n    3\r\n\r\nThis type of programmer error does not cause a warning that can be\r\nreported by the compiler, or flag an error to alert the user at runtime. In\r\nfact, the original version of the code is entirely *valid*, but it does not\r\ncorrectly represent the programmer's intent.  This is just one of many\r\nsituations in which the 'tracing' functionality of PRINTV is\r\nindespensible for quick identification and resolution of errors in\r\ncode semantics.\r\n\r\nBy helping to quickly identify and locate the faulty\r\nsemantics caused by improper order of the COND clauses, PRINTV has\r\npossibly saved you enough time for a coffee-break!\r\n    \r\n#### Extended Typography: Bells, and Whistles\r\n\r\nAs you begin to spend time crafting and annotating your debug-logging\r\noutput, you may start to think of what you include within PRINTV as a\r\nprimitive text markup DSL. And so you may begin to wish for a little\r\nmore typographic panache.  This, at least, occurs for me now and\r\nagain. It is very important, though, that in our pursuit of ever more\r\nbeautiful output we do not introduce artifacts that could change the\r\nmeaning or operation of code enclosed in a PRINTV form.  This limits\r\nour options when choosing the manner in which we can implement such\r\nfeatures.\r\n\r\nYou may have noticed from the first example shiown in section USAGE\r\nthat the keywords `:hr` and `:ts` were used to insert into the log\r\na thin horizontal rule and timestamp, respectively.  For these kinds of\r\nsimple, self-contained tags, it is reasonable that we can choose a few\r\nkeywords such as these and handle them specially when encountered\r\nwithin the implicit progn of a PRINTV. In doing so, we can simply\r\nspecify that they will not be evaluated, effectively returning\r\n`(values)`. Inclusion of these tags will have no effect, even if\r\nthey are used in the final (value-returning) position of the\r\nprogn. Further, the special keywords that control these typographic\r\nfeatures are user-configurable (see CONFIGURABLES, below).\r\n\r\nBe aware, however, that although useful, these typographic extensions\r\nmay potentially at odds with the PRINTV philosophy of pure\r\ntransparency. In particular, although the formatting tags are\r\n\"invisible\" within the scope of PRINTV and returned values of\r\nevaluated forms are automatically passed through to be correctly\r\nreturned form PRINTV when these tags appear in the tail position of\r\nPRINTV's implicit progn, this will not the case if PRINTV is disabled\r\n(see `disable-printv`) or when the printv is removed.  The safest\r\napproach is to never use these tags in the tail position -- making\r\nsure that the final form is the one returning the desired values.  In\r\npractice I have not found this to be difficult to manage, and,\r\npractically speaking, I have not come up with a *totally* safe\r\nalternative means to specify extended formatting.  In my opinion, the\r\nbenefits are worth this small inconvenience; also, one is always free\r\nto ignore the extended formatting features entirely, or even disable\r\nthem by configuring them to be uninterned symbols, like so:\r\n\r\n    (setf *major-separator*      (gensym))\r\n    (setf *minor-separator*      (gensym))\r\n    (setf *timestamp-designator* (gensym))    \r\n\r\nThe following are a few examples which illustrate some PRINTV's that\r\nuse the timestamp, thin and thick rule features:\r\n\r\n    (printv :hr \"Section 1.\" :hr)\r\n\r\nPrints:\r\n\r\n    ;;; ------------------------------------------------------------------------ ;;;\r\n    ;;; Section 1.\r\n    ;;; ------------------------------------------------------------------------ ;;;\r\n    \r\nReturns:\r\n\r\n    \"Section 1.\"\r\n\r\nSimilarly:\r\n\r\n    (printv :ff :hr (* 2 (+ 3 (/ -1 4))) :hr :ff)\r\n\r\nPrints:\r\n\r\n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n    ;;; ======================================================================== ;;;\r\n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n    ;;; ------------------------------------------------------------------------ ;;;\r\n    ;;;   (* 2 (+ 3 (/ -1 4))) => 11/2\r\n    ;;; ------------------------------------------------------------------------ ;;;\r\n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n    ;;; ======================================================================== ;;;\r\n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n\r\nReturns:\r\n\r\n    11/2\r\n\r\nAnother special markup tag (by default) is `:ts`, which causes a\r\nhuman-readable timestamp to be incorporated into the printv log output:\r\n\r\n    (printv :hr :ts :hr (machine-version) :hr)\r\n\r\nPrints:\r\n\r\n    ;;; ------------------------------------------------------------------------ ;;;\r\n    ;;; .............. Wednesday, April 17, 2013 06:39:03 PM EDT ............... ;;;\r\n    ;;; ------------------------------------------------------------------------ ;;;\r\n    ;;;   (MACHINE-VERSION) => \"Intel(R) Xeon(R) CPU           E5462  @ 2.80GHz\"\r\n    ;;; ------------------------------------------------------------------------ ;;;\r\n\r\nReturns:\r\n\r\n    \"Intel(R) Xeon(R) CPU           E5462  @ 2.80GHz\"\r\n\r\n  \r\n\r\n#### Enablement and Control of Output\r\n\r\nA principle design-goal of this PRINTV library is to provide a number\r\nof options of the destinations to where the output may be directed,\r\nand a robust api with which the user may flexibly select one\r\nwithin some particular dynamic extent of program\r\nexecution. Under-the-hood, output control is implemeted using two\r\nspecial-variables: `*default-printv-output*` and `*printv-output*`\r\n(see CONFIGURABLES).\r\n\r\n\r\n\r\n\r\n\r\n#### Macro debugging with PPMX\r\n\r\nAs one last example, using the magic of PPMX we can finally have a\r\nlook at the internal operation of PRINTV itself -- this is very\r\nfrequently necessary when developing extensions to PRINTV.  We will show\r\nthe macroexpansion of a form used in one of our previous examples:\r\n\r\n    (ppmx (printv :hr :ts :hr (machine-version) :hr))\r\n\r\nPrints:\r\n    \r\n    ;;; Form: (PRINTV :HR :TS :HR (MACHINE-VERSION) :HR)\r\n    ;;;\r\n    ;;; Macro expansion:\r\n\r\n    (FLET ((EXP-1 ()\r\n             (LET ((*PRINT-READABLY* NIL) #:G3262)\r\n               (MINOR-SEPARATOR)\r\n               (TIMESTAMP)\r\n               (MINOR-SEPARATOR)\r\n               (FORM-PRINTER '(MACHINE-VERSION))\r\n               (VALUES-PRINTER\r\n                (SETF #:G3262 (FUNCALL # (MULTIPLE-VALUE-LIST (MACHINE-VERSION)))))\r\n               (MINOR-SEPARATOR)\r\n               (VALUES-LIST #:G3262))))\r\n      (ETYPECASE *PRINTV-OUTPUT*\r\n        (NULL (PROGN :HR :TS :HR (MACHINE-VERSION) :HR))\r\n        (PATHNAME\r\n         (BORDEAUX-THREADS:WITH-RECURSIVE-LOCK-HELD (*PRINTV-LOCK*)\r\n           (WITH-OPEN-FILE\r\n               (LOGFILE *PRINTV-OUTPUT* :DIRECTION :OUTPUT :IF-DOES-NOT-EXIST\r\n                :CREATE :IF-EXISTS :APPEND)\r\n             (WITH-PRINTV-OUTPUT-TO (LOGFILE)\r\n               (EXP-1)))))\r\n        (STREAM\r\n         (BORDEAUX-THREADS:WITH-RECURSIVE-LOCK-HELD (*PRINTV-LOCK*)\r\n           (EXP-1)))))\r\n    ;;;\r\n    ;;;     \r\n\r\n    \r\n#### Configurables\r\n\r\n* `*default-printv-output*` [`*trace-output*`]\r\n> Controls the default stream to which PRINTV/PPMX output will be\r\n> directed under the following circumstances: initially on program\r\n> load, subsequent to any evaluation of `(enable-printv)` or to `(enable-printv-output)`\r\n> with stream argument unspecified, or within the dynamic extent of\r\n> `(with-printv-output-to () ...)` macro-call (i.e., *stream*\r\n> argument (second form) as NIL).\r\n\r\n* `*printv-output*` [`*default-printv-output*`]\r\n> The stream to which PRINTV/PPMX is currently directed. Types of\r\n> valid values this may hold include streams (log to stream), pathnames\r\n> (log to file), or null (disable printv). May be\r\n> affected using functions `enable-printv-output` and\r\n> `disable-printv-output` or within the dynamic extent of macro\r\n> call `with-printv-output-to`. See also the more powerful\r\n> 'enablement' controls provided by: `enable-printv`,\r\n> `disable-printv`, `with-printv-enabled`, and `with-printv-disabled.`\r\n\r\n* `*major-separator*` [`:ff`]\r\n> A special keyword defined to create a *thick* horizontal rule in\r\n> printed output; it is not evaluated.\r\n\r\n* `*minor-separator*` [`:hr`]\r\n> A special keyword defined to create a *thin* horizontal rule in\r\n> printed output; it is not evaluated.\r\n\r\n* `*printv-macro-char*` [`#\\^`]\r\n> Character to use as macro-character to implement reader extension\r\n> that will behave as if the next form that follows is enclosed within\r\n> a PRINTV macro-call.  Return values and program operation will be\r\n> unffected, and so may be used as-needed without fear of corrupting\r\n> live code.\r\n\r\n* `*ppmx-macro-char*` [`#\\$`]\r\n> Character to use as macro-character to implement reader extension\r\n> that will behave as if the next form that follows is enclosed within\r\n> a PPMX macro-call.  Note that this expansion will NOT be evaluated, and\r\n> so program operation may necessarily be affected if indescriminantly\r\n> introduced into live code.\r\n\r\n* `*figlet-executable*` [`\"figlet\"`]\r\n> Specifies the path where the desired FIGLET executable is found on\r\n> this system. If provided as simple command name without\r\n> specification of absolute directory (the default), this command will\r\n> be invoked if valid executable with this name can be found in the\r\n> default shell search path of the user who owns the current common-lisp\r\n> process. \r\n\r\n* `*figlet-font*` [`\"standard\"`]\r\n> The name of the (ASCII) 'figlet font' to be used in FIGLET output.\r\n\r\n### Extension\r\n\r\nFor the most part, extensions to PRINTV may be incorporated by\r\nimplementing additional clauses within the function `EXPANDER`, using\r\nthe existing clauses as a template to get started. Typically,\r\nevaluated forms will involve construction of two function-call\r\ns-expressions: a `FORM-PRINTER` to show what is being evaluated, and a\r\n`VALUES-PRINTER` to show the result.\r\n\r\nFor all expansions except those intended as simple typographic\r\ncommands, it is very important that as a result of expansion the\r\nsymbol designated by `RESULT-SYM` is set to a multiple-value-list of\r\nthe evaluation of the original form transformed by the function\r\ndesignated by `VALUES-TRANS-FN`, and is supplied as the argument to\r\nthe `VALUES-PRINTER` function call.\r\n\r\nFor example, the `EXPANDER` clause of a simple, evaluated form appears\r\nas follows. Note the first line which, if it evaluates to a non-nil\r\nvalue, designates the expansion that follows to be the one\r\napplicable for the given form:\r\n\r\n    ((or (consp form) (and (symbolp form) (not (keywordp form))))\r\n      `((form-printer   ',form)\r\n        (values-printer (setf ,result-sym (funcall ,values-trans-fn\r\n                                           (multiple-value-list ,form))))))\r\n                                             \r\n### Desiredata\r\n\r\n1. Cleaner formatted output from LET, LET*, and COND. \r\n2. Consistent \";;;\" prefixing for every line of output for LET, LET*,\r\n   COND, and other multi-line evaluated forms.\r\n3. Dynamic tracking of indent according to structure.\r\n4. Forms with implicit progn occurring within printv should have that\r\n   progn recursively PRINTVed, with incorporation of formatting\r\n   described by items 1, 2, and 3, above.\r\n5. Test Suite\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}